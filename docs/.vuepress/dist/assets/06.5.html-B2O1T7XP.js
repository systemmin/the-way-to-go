import{_ as r,c as p,a as u,b as t,f as n,d as o,e,r as i,o as m}from"./app-DtITwm2S.js";const s={};function f(k,l){const d=i("RouteLink");return m(),p("div",null,[l[40]||(l[40]=u('<h1 id="_6-5-内置函数" tabindex="-1"><a class="header-anchor" href="#_6-5-内置函数"><span>6.5 内置函数</span></a></h1><p>Go 语言拥有一些不需要进行导入操作就可以使用的内置函数。它们有时可以针对不同的类型进行操作，例如：<code>len()</code>、<code>cap()</code> 和 <code>append()</code>，或必须用于系统级的操作，例如：<code>panic()</code>。因此，它们需要直接获得编译器的支持。</p><p>以下是一个简单的列表，我们会在后面的章节中对它们进行逐个深入的讲解。</p>',3)),t("table",null,[l[34]||(l[34]=t("thead",null,[t("tr",null,[t("th",null,"名称"),t("th",null,"说明")])],-1)),t("tbody",null,[l[30]||(l[30]=t("tr",null,[t("td",null,[t("code",null,"close()")]),t("td",null,"用于管道通信")],-1)),l[31]||(l[31]=t("tr",null,[t("td",null,[t("code",null,"len()"),n("、"),t("code",null,"cap()")]),t("td",null,[t("code",null,"len()"),n(" 用于返回某个类型的长度或数量（字符串、数组、切片、"),t("code",null,"map"),n(" 和管道）；"),t("code",null,"cap()"),n(" 是容量的意思，用于返回某个类型的最大容量（只能用于数组、切片和管道，不能用于 "),t("code",null,"map"),n("）")])],-1)),t("tr",null,[l[19]||(l[19]=t("td",null,[t("code",null,"new()"),n("、"),t("code",null,"make()")],-1)),t("td",null,[l[4]||(l[4]=u("<code>new()</code> 和 <code>make()</code> 均是用于分配内存：<code>new()</code> 用于值类型和用户定义的类型，如自定义结构，<code>make</code> 用于内置引用类型（切片、<code>map</code> 和管道）。它们的用法就像是函数，但是将类型作为参数：<code>new(type)</code>、<code>make(type)</code>。<code>new(T)</code> 分配类型 <code>T</code> 的零值并返回其地址，也就是指向类型 <code>T</code> 的指针（详见",20)),o(d,{to:"/chapter-2/10.1.html"},{default:e(()=>l[0]||(l[0]=[n("第 10.1 节")])),_:1}),l[5]||(l[5]=n("）。它也可以被用于基本类型：")),l[6]||(l[6]=t("code",null,"v := new(int)",-1)),l[7]||(l[7]=n("。")),l[8]||(l[8]=t("code",null,"make(T)",-1)),l[9]||(l[9]=n(" 返回类型 ")),l[10]||(l[10]=t("code",null,"T",-1)),l[11]||(l[11]=n(" 的初始化之后的值，因此它比 ")),l[12]||(l[12]=t("code",null,"new()",-1)),l[13]||(l[13]=n(" 进行更多的工作（详见")),o(d,{to:"/chapter-2/07.2.html"},{default:e(()=>l[1]||(l[1]=[n("第 7.2.3/4 节")])),_:1}),l[14]||(l[14]=n("、")),o(d,{to:"/chapter-2/08.1.html"},{default:e(()=>l[2]||(l[2]=[n("第 8.1.1 节")])),_:1}),l[15]||(l[15]=n("和")),o(d,{to:"/chapter-2/14.2.html"},{default:e(()=>l[3]||(l[3]=[n("第 14.2.1 节")])),_:1}),l[16]||(l[16]=n("）。")),l[17]||(l[17]=t("strong",null,[t("code",null,"new()"),n(" 是一个函数，不要忘记它的括号")],-1)),l[18]||(l[18]=n("。"))])]),l[32]||(l[32]=t("tr",null,[t("td",null,[t("code",null,"copy()"),n("、"),t("code",null,"append()")]),t("td",null,"用于复制和连接切片")],-1)),l[33]||(l[33]=t("tr",null,[t("td",null,[t("code",null,"panic()"),n("、"),t("code",null,"recover()")]),t("td",null,"两者均用于错误处理机制")],-1)),t("tr",null,[l[25]||(l[25]=t("td",null,[t("code",null,"print()"),n("、"),t("code",null,"println()")],-1)),t("td",null,[l[21]||(l[21]=n("底层打印函数（详见")),o(d,{to:"/chapter-2/04.2.html"},{default:e(()=>l[20]||(l[20]=[n("第 4.2 节")])),_:1}),l[22]||(l[22]=n("），在部署环境中建议使用 ")),l[23]||(l[23]=t("code",null,"fmt",-1)),l[24]||(l[24]=n(" 包"))])]),t("tr",null,[l[29]||(l[29]=t("td",null,[t("code",null,"complex()"),n("、"),t("code",null,"real ()"),n("、"),t("code",null,"imag()")],-1)),t("td",null,[l[27]||(l[27]=n("用于创建和操作复数（详见")),o(d,{to:"/chapter-2/04.5.html"},{default:e(()=>l[26]||(l[26]=[n("第 4.5.2.2 节")])),_:1}),l[28]||(l[28]=n("）"))])])])]),l[41]||(l[41]=t("h2",{id:"链接",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#链接"},[t("span",null,"链接")])],-1)),t("ul",null,[t("li",null,[o(d,{to:"/chapter-2/directory.html"},{default:e(()=>l[35]||(l[35]=[n("目录")])),_:1})]),t("li",null,[l[37]||(l[37]=n("上一节：")),o(d,{to:"/chapter-2/06.4.html"},{default:e(()=>l[36]||(l[36]=[n("defer 和追踪")])),_:1})]),t("li",null,[l[39]||(l[39]=n("下一节：")),o(d,{to:"/chapter-2/06.6.html"},{default:e(()=>l[38]||(l[38]=[n("递归函数")])),_:1})])])])}const v=r(s,[["render",f],["__file","06.5.html.vue"]]),x=JSON.parse('{"path":"/chapter-2/06.5.html","title":"6.5 内置函数","lang":"zh-cn","frontmatter":{},"headers":[{"level":1,"title":"6.5 内置函数","slug":"_6-5-内置函数","link":"#_6-5-内置函数","children":[{"level":2,"title":"链接","slug":"链接","link":"#链接","children":[]}]}],"git":{},"filePathRelative":"chapter-2/06.5.md"}');export{v as comp,x as data};
