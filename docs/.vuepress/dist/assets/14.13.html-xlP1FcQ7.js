import{_ as o,c as i,a as p,b as s,f as a,d as l,e,r as u,o as c}from"./app-DtITwm2S.js";const d={};function r(k,n){const t=u("RouteLink");return c(),i("div",null,[n[23]||(n[23]=p(`<h1 id="_14-13-在多核心上并行计算" tabindex="-1"><a class="header-anchor" href="#_14-13-在多核心上并行计算"><span>14.13 在多核心上并行计算</span></a></h1><p>假设我们有 <code>NCPU</code> 个 CPU 核心：<code>const NCPU = 4 //对应一个四核处理器</code> 然后我们想把计算量分成 <code>NCPU</code> 个部分，每一个部分都和其他部分并行运行。</p><p>这可以通过以下代码所示的方式完成（我们且省略具体参数）</p><div class="language-go line-numbers-mode" data-highlighter="prismjs" data-ext="go" data-title="go"><pre><code><span class="line"><span class="token keyword">func</span> <span class="token function">DoAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">    sem <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> NCPU<span class="token punctuation">)</span> <span class="token comment">// Buffering optional but sensible</span></span>
<span class="line">    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NCPU<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">go</span> <span class="token function">DoPart</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token comment">// Drain the channel sem, waiting for NCPU tasks to complete</span></span>
<span class="line">    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NCPU<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token operator">&lt;-</span>sem <span class="token comment">// wait for one task to complete</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token comment">// All done.</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">func</span> <span class="token function">DoPart</span><span class="token punctuation">(</span>sem <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// do the part of the computation</span></span>
<span class="line">    sem <span class="token operator">&lt;-</span><span class="token number">1</span> <span class="token comment">// signal that this piece is done</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    runtime<span class="token punctuation">.</span><span class="token function">GOMAXPROCS</span><span class="token punctuation">(</span>NCPU<span class="token punctuation">)</span> <span class="token comment">// runtime.GOMAXPROCS = NCPU</span></span>
<span class="line">    <span class="token function">DoAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,4)),s("ul",null,[n[10]||(n[10]=p("<li><p><code>DoAll()</code> 函数创建了一个 <code>sem</code> 通道，每个并行计算都将在对其发送完成信号；在一个 <code>for</code> 循环中 <code>NCPU</code> 个协程被启动了，每个协程会承担 <code>1/NCPU</code> 的工作量。每一个 <code>DoPart()</code> 协程都会向 <code>sem</code> 通道发送完成信号。</p></li>",1)),s("li",null,[s("p",null,[n[1]||(n[1]=s("code",null,"DoAll()",-1)),n[2]||(n[2]=a(" 会在 ")),n[3]||(n[3]=s("code",null,"for",-1)),n[4]||(n[4]=a(" 循环中等待 ")),n[5]||(n[5]=s("code",null,"NCPU",-1)),n[6]||(n[6]=a(" 个协程完成：")),n[7]||(n[7]=s("code",null,"sem",-1)),n[8]||(n[8]=a(" 通道就像一个信号量，这份代码展示了一个经典的信号量模式。（参见 ")),l(t,{to:"/chapter-3/14.2.html#1427-%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%A8%A1%E5%BC%8F"},{default:e(()=>n[0]||(n[0]=[a("14.2.7")])),_:1}),n[9]||(n[9]=a("）"))])])]),s("p",null,[n[12]||(n[12]=a("在以上运行模型中，您还需将 ")),n[13]||(n[13]=s("code",null,"GOMAXPROCS",-1)),n[14]||(n[14]=a(" 设置为 ")),n[15]||(n[15]=s("code",null,"NCPU",-1)),n[16]||(n[16]=a("（参见 ")),l(t,{to:"/chapter-3/14.1.html#1413-%E4%BD%BF%E7%94%A8-gomaxprocs"},{default:e(()=>n[11]||(n[11]=[a("14.1.3")])),_:1}),n[17]||(n[17]=a("）。"))]),n[24]||(n[24]=s("h2",{id:"链接",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#链接"},[s("span",null,"链接")])],-1)),s("ul",null,[s("li",null,[l(t,{to:"/chapter-3/directory.html"},{default:e(()=>n[18]||(n[18]=[a("目录")])),_:1})]),s("li",null,[n[20]||(n[20]=a("上一节：")),l(t,{to:"/chapter-3/14.12.html"},{default:e(()=>n[19]||(n[19]=[a("协程链")])),_:1})]),s("li",null,[n[22]||(n[22]=a("下一节：")),l(t,{to:"/chapter-3/14.14.html"},{default:e(()=>n[21]||(n[21]=[a("并行化大量数据的计算")])),_:1})])])])}const v=o(d,[["render",r],["__file","14.13.html.vue"]]),f=JSON.parse('{"path":"/chapter-3/14.13.html","title":"14.13 在多核心上并行计算","lang":"zh-cn","frontmatter":{},"headers":[{"level":1,"title":"14.13 在多核心上并行计算","slug":"_14-13-在多核心上并行计算","link":"#_14-13-在多核心上并行计算","children":[{"level":2,"title":"链接","slug":"链接","link":"#链接","children":[]}]}],"git":{},"filePathRelative":"chapter-3/14.13.md"}');export{v as comp,f as data};
