# [代码补全](https://platform.openai.com/docs/guides/code/code-completion-limited-beta)  <Badge text="Limited beta"/>

了解如何生成或操作代码

## 介绍

[Codex 模型系列](/start/模型.html#codex)是我们的 GPT-3 系列的后代，该系列已经过自然语言和数十亿行代码的训练。它最擅长 Python，精通 JavaScript、Go、Perl、PHP、Ruby、Swift、TypeScript、SQL，甚至 Shell 等十几种语言。在最初的有限测试期间，Codex 使用是免费的。[了解更多](https://platform.openai.com/docs/models/codex)。

您可以将 Codex 用于各种任务，包括：

- 将注释变成代码
- 在上下文中完成你的下一行或函数
- 为您带来知识，例如为应用程序查找有用的库或 API 调用
- 添加评论
- 重写代码以提高效率

要查看 Codex 的运行情况，请查看我们的 [Codex JavaScript 沙箱](https://platform.openai.com/codex-javascript-sandbox) 或我们的其他[演示视频](https://www.youtube.com/playlist?list=PLOXw6I10VTv_FhQbbvYh1FvbiaPf43Ve2)。

<img src="https://platform.openai.com/sandbox-screenshot.png">

## 快速开始

下面是一些可以在 Playground 中测试的使用 Codex 的示例。

**说“你好”（Python）**

```python
"""

询问用户的姓名并说“你好”
"""
```

**创建随机名称 (Python)**

```python
"""
1. 创建名字列表
2. 创建姓氏列表
3. 随机组合成100个全名的列表
"""
```

**创建 MySQL 查询 (Python)**

```python
"""
Table customers，columns = [CustomerId, FirstName, LastName, Company, Address, City, State, Country, PostalCode, Phone, Fax, Email, SupportRepId]
为德克萨斯州所有名为 Jane 的客户创建一个 MySQL 查询
"""
query =
```

**解释代码 (JavaScript)**

```javascript
// 函数 1
var fullNames = [];
for (var i = 0; i < 50; i++) {
  fullNames.push(names[Math.floor(Math.random() * names.length)]
    + " " + lastNames[Math.floor(Math.random() * lastNames.length)]);
}

// 函数 1 是做什么的？
```

**[更多例子](https://platform.openai.com/docs/guides/code/more-examples)**

访问我们的[示例库](https://platform.openai.com/examples?category=code)，探索更多为 Codex 设计的提示。

## 最佳实践

**从注释、数据或代码开始**。您可以在我们的 playground 中尝试使用其中一种 Codex 模型（需要时将样式说明作为注释。）

为了让 Codex 创建有用的完成，考虑程序员执行任务需要哪些信息会很有帮助。这可能只是一个清晰的注释或编写有用函数所需的数据，例如变量名称或函数处理的类。

```python
# 创建一个名为“nameImporter”的函数来将名字和姓氏添加到数据库中
```

在此示例中，我们告诉 Codex 调用该函数的内容以及它将执行的任务。

这种方法甚至可以扩展到您可以向 Codex 提供注释和数据库模式示例，以使其为各种数据库编写有用的查询请求。

```python
# Table albums, columns = [AlbumId, Title, ArtistId]
# Table artists, columns = [ArtistId, Name]
# Table media_types, columns = [MediaTypeId, Name]
# Table playlists, columns = [PlaylistId, Name]
# Table playlist_track, columns = [PlaylistId, TrackId]
# Table tracks, columns = [TrackId, Name, AlbumId, MediaTypeId, GenreId, Composer, Milliseconds, Bytes, UnitPrice]

# 为 Adele 的所有专辑创建一个查询
```

当您向 Codex 显示数据库架构时，它能够对如何格式化查询做出有根据的猜测。

**指定语言**。 Codex 了解数十种不同的编程语言。许多人对注释、函数和其他编程语法有相似的约定。通过在注释中指定语言和版本，Codex 能够更好地完成您想要的内容。也就是说，Codex 在风格和语法方面相当灵活。

```python
# R language
# 计算点数组之间的平均距离
```

```python
# Python 3
# 计算点数组之间的平均距离
```

提示 Codex 你想要它做什么。如果您希望 Codex 创建网页，请在您的评论告诉 Codex 下一步应该做什么之后将第一行代码放在 HTML 文档 (`<!DOCTYPE html>`) 中。相同的方法适用于从注释创建函数（在注释之后以 `func` 或 `def` 开头的新行）。

```html
<!-- 创建一个标题为“Kat Katman attorney at paw”的网页' -->
<!DOCTYPE html>
```

[在 Playground 上打开](https://platform.openai.com/playground?model=code-davinci-002&prompt= )

在我们的评论之后放置 `<!DOCTYPE html>` 可以让 Codex 清楚地知道我们想要它做什么。

```python
# 创建一个数到 100 的函数
def counter
```

[在 Playground 上打开](https://platform.openai.com/playground?model=code-davinci-002&prompt=%23%20Create%20a%20function%20to%20count%20to%20100%0A%0Adef%20counter)

如果我们开始编写函数，Codex 将了解下一步需要做什么。

**指定库将帮助 Codex 了解您的需求**。Codex 知道大量的库、API 和模块。通过注释或将它们导入您的代码告诉 Codex 使用哪些，Codex 将根据它们而不是备选方案提出建议。

```html
<!-- 使用A-Frame 1.2.0版制作3D网站 -->
<!-- https://aframe.io/releases/1.2.0/aframe.min.js -->
```

[在 Playground 上打开](https://platform.openai.com/playground?model=code-davinci-002&prompt=%3C%21--%20Use%20A-Frame%20version%201.2.0%20to%20create%20a%203D%20website%20--%3E%0A%3C%21--%20https%3A%2F%2Faframe.io%2Freleases%2F1.2.0%2Faframe.min.js%20--%3E)

通过指定版本，您可以确保 Codex 使用最新的库。

注意：Codex 可以推荐有用的库和 API，但请始终确保自己进行研究以确保它们对您的应用程序是安全的。

**注释风格会影响代码质量**。对于某些语言，注释的风格可以提高输出的质量。例如，在使用 Python 时，在某些情况下使用文档字符串（用三引号引起来的注释）可以提供比使用井号 (#) 符号更高质量的结果。

```python
'''
创建一组用户和电子邮件地址
'''
```

[在 Playground 上打开](https://platform.openai.com/playground?model=code-davinci-002&prompt=%22%22%22%0ACreate%20an%20array%20of%20users%20and%20email%20addresses%0A%22%22%22)

**将注释放在函数内部可能会有所帮助**。推荐的编码标准通常建议将函数的描述放在函数内部。使用这种格式有助于 Codex 更清楚地了解您希望函数执行的操作。

```python
def getUserBalance(id):
    """
    在数据库“UserData”中查找用户并返回他们当前的账户余额。
    """
```

[在 Playground 上打开](https://platform.openai.com/playground?model=code-davinci-002&prompt=def%20getUserBalance%28id%29%3A%0A%20%20%20%20%22%22%22%0A%20%20%20%20Look%20up%20the%20user%20in%20the%20database%20%E2%80%98UserData%27%20and%20return%20their%20current%20account%20balance.%0A%20%20%20%20%22%22%22)

**提供示例以获得更精确的结果**。如果您有需要 Codex 使用的特定样式或格式，请在请求的第一部分提供示例或演示，这将有助于 Codex 更准确地满足您的需求。

```python
"""
创建随机动物和物种的列表

"""
animals  = [ {"name": "Chomper", "species": "Hamster"}, {"name":
```

**较低的温度可提供更精确的结果**。在大多数情况下，将 API 温度设置为 0 或接近于零（例如 0.1 或 0.2）往往会产生更好的结果。与 GPT-3 不同，更高的温度可以提供有用的创造性和随机结果，Codex 的更高温度可能会给你真正随机或不稳定的响应。

如果您需要 Codex 提供不同的潜在结果，请从零开始，然后向上递增 0.1，直到找到合适的变化。

**将任务组织成功能**。我们可以通过在注释中尽可能准确地指定函数应该做什么来让 Codex 编写函数。通过编写以下注释，Codex 创建了一个 Javascript 计时器函数，该函数在用户按下按钮时触发：

一个简单的 JavaScript 计时器

```javascript
// 创建一个在 10 秒内创建警报的计时器
```

我们可以使用 Codex 与众所周知的库一起执行常见任务，例如使用 Stripe API 创建客户：

在 Python 中创建 Stripe 客户

```python
# 从电子邮件地址创建一个 Stripe 客户
```

**创建示例数据**。测试应用程序通常需要使用示例数据。因为 Codgen 是一种理解如何理解和编写自然语言的语言模型，所以您可以要求 Codex 创建数据，例如虚构名称、产品和其他变量的数组。

```javascript
/* 为旧金山创建一个天气温度数组 */
```

要求 Codex 执行此任务将生成如下表格：

```javascript
var weather = [
  { month: 'January', high: 58, low: 48 },
  { month: 'February', high: 61, low: 50 },
  { month: 'March', high: 64, low: 53 },
  { month: 'April', high: 67, low: 55 },
  { month: 'May', high: 70, low: 58 },
  { month: 'June', high: 73, low: 61 },
  { month: 'July', high: 76, low: 63 },
  { month: 'August', high: 77, low: 64 },
  { month: 'September', high: 76, low: 63 },
  { month: 'October', high: 73, low: 61 },
  { month: 'November', high: 68, low: 57 },
  { month: 'December', high: 64, low: 54 }
];
```

**复合函数和小型应用程序**。我们可以向 Codex 提供包含复杂请求的评论，例如创建随机名称生成器或使用用户输入执行任务，如果有足够的标记，Codex 可以生成其余内容。

```javascript
/*
创建动物列表
创建城市列表
使用列表来生成关于我在每个城市的动物园看到的故事
*/
```

**限制完成大小以获得更精确的结果或更低的延迟**。在 Codex 中请求更长的完成时间可能会导致不准确的答案和重复。通过减少`max_tokens`和设置`stop`标记来限制查询的大小。例如，添加`\n`为`stop`序列以将完成限制为一行代码。较小的完成也会导致较少的延迟。

**使用流式传输来减少延迟**。大型 Codex 查询可能需要数十秒才能完成。要构建需要较低延迟的应用程序，例如执行自动完成的编码助手，请考虑使用流式处理。在模型完成生成整个完成之前将返回响应。只需要部分完成的应用程序可以通过以编程方式或通过使用创造性的值来切断完成来减少延迟`stop`。

用户可以通过从 API 请求多个解决方案并使用返回的第一个响应，将流式处理与复制结合起来以减少延迟。通过设置来做到这一点`n > 1`。这种方式会消耗较多的token配额，谨慎使用（比如合理设置`max_tokens`和`stop`）。

**使用 Codex 来解释代码**。Codex 创建和理解代码的能力使我们能够使用它来执行任务，例如解释文件中代码的作用。实现此目的的一种方法是在以“This function”或“This application is”开头的函数之后添加注释。食典委通常将此解释为解释的开始并完成文本的其余部分。

```javascript
/* 解释前面的函数在做什么：它
```

**解释 SQL 查询**。在此示例中，我们使用 Codex 以人类可读的格式解释 SQL 查询的作用。

```sql
SELECT DISTINCT department.name
FROM department
JOIN employee ON department.id = employee.department_id
JOIN salary_payments ON employee.id = salary_payments.employee_id
WHERE salary_payments.date BETWEEN '2020-06-01' AND '2020-06-30'
GROUP BY department.name
HAVING COUNT(employee.id) > 10;
-- 以人类可读的格式解释上述查询
--
```

**编写单元测试**。只需添加注释“单元测试”并启动一个函数，即可在 Python 中创建单元测试。

```python
# Python 3
def sum_numbers(a, b):
  return a + b

# Unit test
def
```

**检查代码是否有错误**。通过使用示例，您可以向 Codex 展示如何识别代码中的错误。在某些情况下不需要示例，但是展示提供描述的级别和细节可以帮助法典理解要寻找的内容以及如何解释它。（Codex 对错误的检查不应取代用户的仔细审查。）

```javascript
/* 解释为什么前面的函数不起作用。 */
```

**使用源数据编写数据库函数**。正如人类程序员会从了解数据库结构和列名中获益一样，Codex 可以使用此数据来帮助您编写准确的查询请求。在此示例中，我们插入数据库的模式并告诉 Codex 要查询数据库的内容。

```python
# Table albums, columns = [AlbumId, Title, ArtistId]
# Table artists, columns = [ArtistId, Name]
# Table media_types, columns = [MediaTypeId, Name]
# Table playlists, columns = [PlaylistId, Name]
# Table playlist_track, columns = [PlaylistId, TrackId]
# Table tracks, columns = [TrackId, Name, AlbumId, MediaTypeId, GenreId, Composer, Milliseconds, Bytes, UnitPrice]

# 为 Adele 的所有专辑创建一个查询
```

**语言之间的转换**。您可以让 Codex 从一种语言转换为另一种语言，方法是遵循一种简单的格式，您可以在注释中列出要转换的代码的语言，然后是代码，然后是包含您希望将其翻译成的语言的注释。

```python
# 将其从 Python 转换为 R
# Python version

[ Python code ]

# End

# R version
```

**为库或框架重写代码**。如果您希望 Codex 提高某个功能的效率，您可以为其提供要重写的代码，然后提供有关使用何种格式的说明。

```javascript
// 将其重写为 React 组件
var input = document.createElement('input');
input.setAttribute('type', 'text');
document.body.appendChild(input);
var button = document.createElement('button');
button.innerHTML = 'Say Hello';
document.body.appendChild(button);
button.onclick = function() {
  var name = input.value;
  var hello = document.createElement('div');
  hello.innerHTML = 'Hello ' + name;
  document.body.appendChild(hello);
};

// React version:
```

## 插入代码 <Badge text="beta" />

补全端点还支持通过提供除[前缀提示](/api/补全.html#前缀)之外的[后缀提示](/api/补全.html#后缀)来在代码中插入代码。这可用于在函数或文件中间插入补全。

```python
def get_largest_prime_factor(n):
    if n < 2:
        return False
    def is_prime(n): >  for i in range(2, n): >  if n % i == 0: >  return False >  return True >     largest = 1
    for j in range(2, n + 1):
        if n % j == 0 and is_prime(j):
    return largest
```

通过为模型提供额外的上下文，它可以更加可控。然而，这对模型来说是一个更具约束性和挑战性的任务。

### 最佳实践

插入代码是测试版中的一项新功能，您可能需要修改使用 API 的方式以获得更好的结果。以下是一些最佳实践：

**使用 max_tokens > 256**。该模型更擅长插入更长的补全。如果 max_tokens 太小，模型可能会在连接到后缀之前被切断。请注意，即使使用更大的 max_tokens，您也只会根据生成的标记数量付费。

**更喜欢 finish_reason == “stop”**。当模型到达自然停止点或用户提供的停止序列时，它会将 finish_reason 设置为“停止”。这表明该模型已设法很好地连接到后缀，并且是完成质量的良好信号。这对于在使用 n > 1 或重采样时在几个完成之间进行选择尤其相关（请参阅下一点）。

**重新采样 3-5 次**。虽然几乎所有补全都连接到前缀，但在更困难的情况下，模型可能难以连接后缀。我们发现，在这种情况下，重采样 3 或 5 次（或使用 best_of 和 k=3,5）并选择带有“stop”作为其 finish_reason 的样本可能是一种有效的方法。重采样时，您通常需要更高的温度来增加多样性。

注意：如果所有返回的样本都有 finish_reason == "length"，很可能是 max_tokens 太小，模型在设法自然地连接提示和后缀之前用完了标记。考虑在重采样之前增加 max_tokens。

## 编辑代码 <Badge text="beta" />

[编辑](/api/编辑)端点可用于编辑代码，而不仅仅是补全代码。您提供一些代码和如何修改它的说明，`code-davinci-edit-001`模型将尝试相应地对其进行编辑。这是重构和调整代码的自然界面。在此初始测试期间，编辑端点的使用是免费的。

### 例子

#### 迭代构建程序

编写代码通常是一个迭代过程，需要一路完善文本。编辑自然而然地不断完善模型的输出，直到最终结果得到完善。在此示例中，我们使用斐波那契作为如何迭代构建代码的示例。

#### 1.写一个函数

**输入**

<CodeDesc ctt="无输入"/>

**指示**

<CodeDesc ctt="用python写一个计算斐波那契的函数"/>

**输出**

 ```python
 def fibonacci(num):
     a = 0
     b = 1
     if num ==1:
        print(a)
     else:
         print(a)
         print(b)
         # 序列从0,1开始
         for i in range(2,num):
             c = a+b
             a = b
             b = c
             print(c)
 
 fibonacci(10)
 ```

#### 2.重构它

输入

 ```python
 def fibonacci(num):
     a = 0
     b = 1
     if num ==1:
        print(a)
     else:
         print(a)
         print(b)
         # 序列从0,1开始
         for i in range(2,num):
             c = a+b
             a = b
             b = c
             print(c)
 
 fibonacci(10)
 ```

**指示**

<CodeDesc ctt="将此函数重构为递归的"/>

**输出**

 ```python
 def fib(num):
     if num <= 1:
           return num
       else:
         return fib(num-1) + fib(num-2)
 print(fib(10))
 ``` 

#### 3.重命名函数

**输入**

 ```python
 def fibonacci(num):
     if num <= 1:
         return num
     else:
         return fib(num-1) + fib(num-2)
 print(fibonacci(10))
 ```

**指示**

<CodeDesc ctt="将函数重命名为 fib"/>

**输出**

 ```python
 def fib(num):
     if num <= 1:
           return num
       else:
         return fib(num-1) + fib(num-2)
 print(fib(10))
 ```

#### 4.添加文档

**输入**

 ```python
 def fib(num):
     if num <= 1:
         return num
     else:
         return fib(num-1) + fib(num-2)
 print(fib(10))
 ```

**指示**

<CodeDesc ctt="添加文档"/>
 

**输出**

 ```python
 def fib(num):
     """ 打印斐波那契数列中的第 n 个数 """
     if num <= 1:
           return num
       else:
           return fib(num-1) + fib(num-2)
   print(fib(10))
 ```

### 最佳实践

编辑端点仍处于 alpha 阶段，我们建议遵循这些最佳实践。

1. 考虑使用空提示！在这种情况下，编辑可以类似于完成使用。
2. 说明尽可能具体。
3. 有时，模型无法找到解决方案并会导致错误。我们建议改写您的说明或输入。